using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using Windows.Win32;
using Windows.Win32.Foundation;
using Windows.Win32.UI.Accessibility;

namespace TermBar.Models {
  /// <summary>
  /// The window list.
  /// </summary>
  /// <remarks>Intended to be interfaced with via <see
  /// cref="System.Collections.Specialized.INotifyCollectionChanged"/> and <see
  /// cref="INotifyPropertyChanged"/>.</remarks>
#pragma warning disable IDE0079 // Remove unnecessary suppression
  [System.Diagnostics.CodeAnalysis.SuppressMessage("Usage", "CsWinRT1028:Class is not marked partial", Justification = "Is a model")]
#pragma warning restore IDE0079 // Remove unnecessary suppression
  public class WindowList : INotifyPropertyChanged, IEnumerable<Window>, IList<Window> {
    public event PropertyChangedEventHandler? PropertyChanged;

    private readonly WINEVENTPROC winSystemEventProc;
    private readonly WINEVENTPROC winObjectEventProc;

    // TODO: need a lock on this
    private readonly ObservableCollection<Window> windows;

    private static Window? foregroundedWindow;

    private static readonly WindowList instance = new();

    /// <summary>
    /// The singleton instance.
    /// </summary>
    public static WindowList Instance => instance;

    /// <summary>
    /// The list of <see cref="Window"/>s to be presented to the
    /// user.
    /// </summary>
    public static ObservableCollection<Window> Windows => Instance.windows;

    /// <summary>
    /// The currently foregrounded window.
    /// </summary>
    public static Window? ForegroundedWindow {
      get => foregroundedWindow;

      set {
        if (foregroundedWindow != value) {
          foregroundedWindow = value;

          if (foregroundedWindow is not null) {
            WindowListHelper.Foreground(Instance.windows, foregroundedWindow.HWnd);
          }

          Instance.OnPropertyChanged();
        }
      }
    }

    /// <summary>
    /// Iconifies the foregrounded window.
    /// </summary>
    public static void Iconify() {
      if (foregroundedWindow is not null) {
        WindowListHelper.Iconify(Instance.windows, foregroundedWindow.HWnd);
      }
    }

    /// <summary>
    /// Initializes a <see cref="WindowList"/>.
    /// </summary>
    private WindowList() {
      windows = WindowListHelper.EnumerateWindows();
      winSystemEventProc = new(WinSystemEventProc);
      winObjectEventProc = new(WinObjectEventProc);

      _ = PInvoke.SetWinEventHook(
        WindowListHelper.EVENT_SYSTEM_FOREGROUND,
        WindowListHelper.EVENT_SYSTEM_FOREGROUND,
        (HMODULE) (nint) 0,
        winSystemEventProc,
        0,
        0,
        WindowListHelper.WINEVENT_OUTOFCONTEXT | WindowListHelper.WINEVENT_SKIPOWNPROCESS
      );

      _ = PInvoke.SetWinEventHook(
        WindowListHelper.EVENT_OBJECT_CREATE,
        WindowListHelper.EVENT_OBJECT_NAMECHANGE,
        (HMODULE) (nint) 0,
        winObjectEventProc,
        0,
        0,
        WindowListHelper.WINEVENT_OUTOFCONTEXT | WindowListHelper.WINEVENT_SKIPOWNPROCESS
      );
    }

    /// <summary>
    /// Handles event <c>EVENT_SYSTEM_FOREGROUND</c>.
    /// </summary>
    /// <remarks>
    /// <para>An application-defined callback (or hook) function that the
    /// system calls in response to events generated by an accessible object.
    /// The hook function processes the event notifications as required.
    /// Clients install the hook function and request specific types of event
    /// notifications by calling <see cref="PInvoke.SetWinEventHook"/>.</para>
    /// <para>The <see cref="WINEVENTPROC"/> type defines a pointer to this
    /// callback function. <c>WinEventProc</c> is a placeholder for the
    /// application-defined function name.</para>
    /// </remarks>
    /// <param name="hWinEventHook">Handle to an event hook function. This
    /// value is returned by <see cref="PInvoke.SetWinEventHook"/> when the
    /// hook function is installed and is specific to each instance of the hook
    /// function.</param>
    /// <param name="event">Specifies the event that occurred. This value is
    /// one of the event constants.</param>
    /// <param name="hWnd">Handle to the window that generates the event, or
    /// <c>null</c> if no window is associated with the event. For example, the
    /// mouse pointer is not associated with a window.</param>
    /// <param name="idObject">Identifies the object associated with the event.
    /// This is one of the object identifiers or a custom object ID.</param>
    /// <param name="idChild">Identifies whether the event was triggered by an
    /// object or a child element of the object. If this value is
    /// <c>CHILDID_SELF</c>, the event was triggered by the object; otherwise,
    /// this value is the child ID of the element that triggered the
    /// event.</param>
    /// <param name="idEventThread"></param>
    /// <param name="dwmsEventTime">Specifies the time, in milliseconds, that
    /// the event was generated.</param>
    private void WinSystemEventProc(
      HWINEVENTHOOK hWinEventHook,
      uint @event,
      HWND hWnd,
      int idObject,
      int idChild,
      uint idEventThread,
      uint dwmsEventTime
    ) {
      Window? window = WindowListHelper.IsForegrounded(windows, @event, hWnd);

      if (window is not null) ForegroundedWindow = window;
    }

    /// <summary>
    /// Handles events <c>EVENT_OBJECT_CREATE</c> through
    /// <c>EVENT_OBJECT_NAMECHANGE</c>.
    /// </summary>
    /// <remarks>
    /// <para>An application-defined callback (or hook) function that the
    /// system calls in response to events generated by an accessible object.
    /// The hook function processes the event notifications as required.
    /// Clients install the hook function and request specific types of event
    /// notifications by calling <see cref="PInvoke.SetWinEventHook"/>.</para>
    /// <para>The <see cref="WINEVENTPROC"/> type defines a pointer to this
    /// callback function. <c>WinEventProc</c> is a placeholder for the
    /// application-defined function name.</para>
    /// </remarks>
    /// <param name="hWinEventHook">Handle to an event hook function. This
    /// value is returned by <see cref="PInvoke.SetWinEventHook"/> when the
    /// hook function is installed and is specific to each instance of the hook
    /// function.</param>
    /// <param name="event">Specifies the event that occurred. This value is
    /// one of the event constants.</param>
    /// <param name="hWnd">Handle to the window that generates the event, or
    /// <c>null</c> if no window is associated with the event. For example, the
    /// mouse pointer is not associated with a window.</param>
    /// <param name="idObject">Identifies the object associated with the event.
    /// This is one of the object identifiers or a custom object ID.</param>
    /// <param name="idChild">Identifies whether the event was triggered by an
    /// object or a child element of the object. If this value is
    /// <c>CHILDID_SELF</c>, the event was triggered by the object; otherwise,
    /// this value is the child ID of the element that triggered the
    /// event.</param>
    /// <param name="idEventThread"></param>
    /// <param name="dwmsEventTime">Specifies the time, in milliseconds, that
    /// the event was generated.</param>
    private void WinObjectEventProc(
      HWINEVENTHOOK hWinEventHook,
      uint @event,
      HWND hWnd,
      int idObject,
      int idChild,
      uint idEventThread,
      uint dwmsEventTime
    ) => WindowListHelper.UpdateWindow(
      windows,
      @event,
      hWnd
    );

    Window IList<Window>.this[int index] { get => windows[index]; set => windows[index] = value; }

    int ICollection<Window>.Count => windows.Count;

    bool ICollection<Window>.IsReadOnly => true;

    void ICollection<Window>.Add(Window item) => windows.Add(item);
    void ICollection<Window>.Clear() => windows.Clear();
    bool ICollection<Window>.Contains(Window item) => windows.Contains(item);
    void ICollection<Window>.CopyTo(Window[] array, int arrayIndex) => windows.CopyTo(array, arrayIndex);

    IEnumerator<Window> IEnumerable<Window>.GetEnumerator() => new WindowListViewModelEnumerator(windows);

    IEnumerator IEnumerable.GetEnumerator() => new WindowListViewModelEnumerator(windows);

    int IList<Window>.IndexOf(Window item) => windows.IndexOf(item);
    void IList<Window>.Insert(int index, Window item) => windows.Insert(index, item);
    bool ICollection<Window>.Remove(Window item) => windows.Remove(item);
    void IList<Window>.RemoveAt(int index) => windows.RemoveAt(index);

    private void OnPropertyChanged([CallerMemberName] string? callerMemberName = null) => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(callerMemberName));
  }

  internal partial class WindowListViewModelEnumerator(ObservableCollection<Window> windows) : IEnumerator<Window> {
    private int index = -1;
    private bool disposedValue;

    object IEnumerator.Current {
      get {
        try {
          return windows[index];
        } catch (IndexOutOfRangeException) {
          throw new InvalidOperationException();
        }
      }
    }

    Window IEnumerator<Window>.Current {
      get {
        try {
          return windows[index];
        } catch (IndexOutOfRangeException) {
          throw new InvalidOperationException();
        }
      }
    }

    bool IEnumerator.MoveNext() {
      index++;

      return index < windows.Count;
    }

    void IEnumerator.Reset() => index = -1;

    public void Dispose() {
      // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
      Dispose(disposing: true);
      GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing) {
      if (!disposedValue) {
        if (disposing) {
          // TODO: dispose managed state (managed objects)
        }

        disposedValue = true;
      }
    }
  }
}
