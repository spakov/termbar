#if DEBUG
using Microsoft.Extensions.Logging;
#endif
using Microsoft.UI.Dispatching;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using Windows.Win32;
using Windows.Win32.Foundation;
using Windows.Win32.UI.Accessibility;

namespace Spakov.TermBar.Models {
  /// <summary>
  /// The window list.
  /// </summary>
  /// <remarks>Intended to be interfaced with via <see
  /// cref="System.Collections.Specialized.INotifyCollectionChanged"/> and <see
  /// cref="INotifyPropertyChanged"/>.</remarks>
#pragma warning disable IDE0079 // Remove unnecessary suppression
  [System.Diagnostics.CodeAnalysis.SuppressMessage("Usage", "CsWinRT1028:Class is not marked partial", Justification = "Is a model")]
#pragma warning restore IDE0079 // Remove unnecessary suppression
  public class WindowList : INotifyPropertyChanged {
#if DEBUG
    internal readonly ILogger logger;
    internal static readonly LogLevel logLevel = App.logLevel;
#endif

    public event PropertyChangedEventHandler? PropertyChanged;

    private readonly DispatcherQueue dispatcherQueue;

    private readonly WINEVENTPROC winSystemEventProc;
    private readonly WINEVENTPROC winObjectEventProc;

    private readonly ObservableCollection<Window> windows;

    private static Window? foregroundedWindow;

    private static WindowList? instance;

    /// <summary>
    /// The singleton instance.
    /// </summary>
    public static WindowList? Instance {
      get => instance;
      internal set => instance = value;
    }

    /// <summary>
    /// The list of <see cref="Window"/>s to be presented to the
    /// user.
    /// </summary>
    public static ObservableCollection<Window> Windows => Instance!.windows;

    /// <summary>
    /// The currently foregrounded window.
    /// </summary>
    public static Window? ForegroundedWindow {
      get => foregroundedWindow;

      set {
        if (foregroundedWindow != value) {
          foregroundedWindow = value;

          if (foregroundedWindow is not null) {
#if DEBUG
            WindowListHelper.Foreground(Instance!.logger, Instance!.windows, foregroundedWindow.HWnd);
#else
            WindowListHelper.Foreground(Instance!.windows, foregroundedWindow.HWnd);
#endif
          }

          Instance!.OnPropertyChanged();
        }
      }
    }

    /// <summary>
    /// Iconifies the foregrounded window.
    /// </summary>
    public static void Iconify() {
      if (foregroundedWindow is not null) {
#if DEBUG
        WindowListHelper.Iconify(Instance!.logger, Instance!.windows, foregroundedWindow.HWnd);
#else
        WindowListHelper.Iconify(Instance!.windows, foregroundedWindow.HWnd);
#endif
      }
    }

    /// <summary>
    /// Initializes a <see cref="WindowList"/>.
    /// </summary>
    internal WindowList(DispatcherQueue dispatcherQueue) {
#if DEBUG
      using ILoggerFactory factory = LoggerFactory.Create(
        builder => {
          builder.AddDebug();
          builder.SetMinimumLevel(logLevel);
        }
      );

      logger = factory.CreateLogger<WindowList>();
#endif

      this.dispatcherQueue = dispatcherQueue;

#if DEBUG
      windows = WindowListHelper.EnumerateWindows(logger);
#else
      windows = WindowListHelper.EnumerateWindows();
#endif

      winSystemEventProc = new(WinSystemEventProc);
      winObjectEventProc = new(WinObjectEventProc);

      _ = PInvoke.SetWinEventHook(
        WindowListHelper.EVENT_SYSTEM_FOREGROUND,
        WindowListHelper.EVENT_SYSTEM_FOREGROUND,
        (HMODULE) (nint) 0,
        winSystemEventProc,
        0,
        0,
        WindowListHelper.WINEVENT_OUTOFCONTEXT | WindowListHelper.WINEVENT_SKIPOWNPROCESS
      );

      _ = PInvoke.SetWinEventHook(
        WindowListHelper.EVENT_OBJECT_CREATE,
        WindowListHelper.EVENT_OBJECT_NAMECHANGE,
        (HMODULE) (nint) 0,
        winObjectEventProc,
        0,
        0,
        WindowListHelper.WINEVENT_OUTOFCONTEXT | WindowListHelper.WINEVENT_SKIPOWNPROCESS
      );
    }

    /// <summary>
    /// Handles event <c>EVENT_SYSTEM_FOREGROUND</c>.
    /// </summary>
    /// <remarks>
    /// <para>An application-defined callback (or hook) function that the
    /// system calls in response to events generated by an accessible object.
    /// The hook function processes the event notifications as required.
    /// Clients install the hook function and request specific types of event
    /// notifications by calling <see cref="PInvoke.SetWinEventHook"/>.</para>
    /// <para>The <see cref="WINEVENTPROC"/> type defines a pointer to this
    /// callback function. <c>WinEventProc</c> is a placeholder for the
    /// application-defined function name.</para>
    /// </remarks>
    /// <param name="hWinEventHook">Handle to an event hook function. This
    /// value is returned by <see cref="PInvoke.SetWinEventHook"/> when the
    /// hook function is installed and is specific to each instance of the hook
    /// function.</param>
    /// <param name="event">Specifies the event that occurred. This value is
    /// one of the event constants.</param>
    /// <param name="hWnd">Handle to the window that generates the event, or
    /// <c>null</c> if no window is associated with the event. For example, the
    /// mouse pointer is not associated with a window.</param>
    /// <param name="idObject">Identifies the object associated with the event.
    /// This is one of the object identifiers or a custom object ID.</param>
    /// <param name="idChild">Identifies whether the event was triggered by an
    /// object or a child element of the object. If this value is
    /// <c>CHILDID_SELF</c>, the event was triggered by the object; otherwise,
    /// this value is the child ID of the element that triggered the
    /// event.</param>
    /// <param name="idEventThread"></param>
    /// <param name="dwmsEventTime">Specifies the time, in milliseconds, that
    /// the event was generated.</param>
    private void WinSystemEventProc(
      HWINEVENTHOOK hWinEventHook,
      uint @event,
      HWND hWnd,
      int idObject,
      int idChild,
      uint idEventThread,
      uint dwmsEventTime
    ) {
#if DEBUG
      Window? window = WindowListHelper.IsForegrounded(logger, windows, @event, hWnd);
#else
      Window? window = WindowListHelper.IsForegrounded(windows, @event, hWnd);
#endif

      if (window is not null) ForegroundedWindow = window;
    }

    /// <summary>
    /// Handles events <c>EVENT_OBJECT_CREATE</c> through
    /// <c>EVENT_OBJECT_NAMECHANGE</c>.
    /// </summary>
    /// <remarks>
    /// <para>An application-defined callback (or hook) function that the
    /// system calls in response to events generated by an accessible object.
    /// The hook function processes the event notifications as required.
    /// Clients install the hook function and request specific types of event
    /// notifications by calling <see cref="PInvoke.SetWinEventHook"/>.</para>
    /// <para>The <see cref="WINEVENTPROC"/> type defines a pointer to this
    /// callback function. <c>WinEventProc</c> is a placeholder for the
    /// application-defined function name.</para>
    /// </remarks>
    /// <param name="hWinEventHook">Handle to an event hook function. This
    /// value is returned by <see cref="PInvoke.SetWinEventHook"/> when the
    /// hook function is installed and is specific to each instance of the hook
    /// function.</param>
    /// <param name="event">Specifies the event that occurred. This value is
    /// one of the event constants.</param>
    /// <param name="hWnd">Handle to the window that generates the event, or
    /// <c>null</c> if no window is associated with the event. For example, the
    /// mouse pointer is not associated with a window.</param>
    /// <param name="idObject">Identifies the object associated with the event.
    /// This is one of the object identifiers or a custom object ID.</param>
    /// <param name="idChild">Identifies whether the event was triggered by an
    /// object or a child element of the object. If this value is
    /// <c>CHILDID_SELF</c>, the event was triggered by the object; otherwise,
    /// this value is the child ID of the element that triggered the
    /// event.</param>
    /// <param name="idEventThread"></param>
    /// <param name="dwmsEventTime">Specifies the time, in milliseconds, that
    /// the event was generated.</param>
    private void WinObjectEventProc(
      HWINEVENTHOOK hWinEventHook,
      uint @event,
      HWND hWnd,
      int idObject,
      int idChild,
      uint idEventThread,
      uint dwmsEventTime
    ) => dispatcherQueue.TryEnqueue(() => WindowListHelper.UpdateWindow(
#if DEBUG
      logger,
#endif
      windows,
      @event,
      hWnd
    ));

    private void OnPropertyChanged([CallerMemberName] string? callerMemberName = null) => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(callerMemberName));
  }
}